# گزارش نهایی پروژه درس «روش‌های صوری»

## مشخصات دانشجو
- نام و نام خانوادگی: **مهدی مالوردی**
- شماره دانشجویی: **404443150**
- تاریخ: **2026-01-30**

## 1) خلاصه مقاله مرجع
**عنوان:** Detecting Redundant Preconditions  
**نویسندگان:** Nicola Thoben, Heike Wehrheim  
**منبع:** FormaliSE 2025 (IEEE/ACM) — DOI: 10.1109/FORMALISE66629.2025.00015  

### مسئله
در «Design by Contract» قراردادها معمولاً با مجموعه‌ای از پیش‌شرط‌ها (Preconditions) و پس‌شرط‌ها (Postconditions) نوشته می‌شوند. هدف مقاله بررسی کیفیت قراردادهاست: آیا برخی پیش‌شرط‌ها **زائد** هستند (یعنی حتی بدون آن‌ها هم پس‌شرط‌ها برقرار می‌مانند)؟

### تعریف افزونگی (Redundancy)
یک پیش‌شرط `pre_i` در مجموعه `Pre` زائد است اگر برنامه با حذف آن پیش‌شرط، همچنان قرارداد را ارضا کند (به‌صورت `P |= (Pre \\ {pre_i}, Post)`).
مقاله علاوه بر افزونگی تکی، مفهوم **افزونگی گروهی** (group-redundant) را هم تعریف می‌کند.

### روش‌های پیشنهادی مقاله
مقاله سه تکنیک برای کشف پیش‌شرط‌های زائد ارائه می‌کند:
1. **IC (Implication Checking):** بررسی می‌کند آیا `pre_i` به‌صورت منطقی از بقیه‌ی پیش‌شرط‌ها نتیجه می‌شود یا نه.
2. **DC (Dependency Calculation):** روی CFA توسعه‌یافته، وابستگی‌های داده/کنترل بین `assume`ها و `assert`ها را بررسی می‌کند؛ اگر پیش‌شرط به هیچ پس‌شرطی وابسته نباشد، زائد است (روش نحوی/سینتکتیک).
3. **PC (Predicate Checking):** با predicate analysis و CEGAR و ساخت ARG بررسی می‌کند آیا در یالِ `assume(b)`، predicate بعد از آن تغییر/تقویت می‌شود یا نه؛ اگر تقویت نشود، آن پیش‌شرط زائد است.

### نتایج تجربی مقاله (خیلی خلاصه)
روی 62 برنامه C و 155 پیش‌شرط زائد تزریق‌شده:
- IC: 61/155
- DC: 62/155
- PC: 147/155
همچنین PC منابع بیشتری (زمان/حافظه) مصرف می‌کند.

## 2) کانتریبوشن جدید (در صورت وجود)
- **(در صورت داشتن ایده/بهبود نسبت به مقاله اینجا بنویسید.)**
- در این پروژه یک پیاده‌سازی آموزشی کوچک (prototype) برای بررسی افزونگی پیش‌شرط‌ها به‌صورت **bounded** ارائه شده است تا ایده‌های مقاله قابل اجرا و مشاهده باشد.

## 3) پیاده‌سازی و نتایج اجرای کد
### توضیح پیاده‌سازی
فایل `fm_project/redundancy_checker.py` یک ابزار ساده است که:
- یک برنامه‌ی کوچک را از روی فایل JSON می‌خواند (شامل `pre`, `post`, و بدنه‌ی برنامه با `assign/while/if`).
- ورودی‌ها را در یک بازه‌ی محدود (bounded domain) enumerate می‌کند.
- صحت قرارداد را در این دامنه بررسی می‌کند.
- برای هر پیش‌شرط، با حذف آن و اجرای دوباره، افزونگی تکی را بررسی می‌کند (شبیه ایده‌ی «successive verification runs»).
- یک بررسی **IC-like** هم انجام می‌دهد: آیا پیش‌شرط از بقیه‌ی پیش‌شرط‌ها (در همان دامنه محدود) نتیجه می‌شود یا نه.

### نتایج نمونه (Example)
نمونه‌ی `examples/sub.json` نسخه‌ی ساده‌شده‌ی مثال مقاله/اسلاید است (متغیرهای `N` و `M` و حلقه).

**دستور اجرا:**
```bash
.venv/bin/python main.py --spec examples/sub.json
```

**خروجی اجرا:**  
خروجی دقیقِ اجرا در فایل `outputs/run_results.txt` ذخیره شده است. خلاصه‌ی نتیجه روی این مثال (در دامنه‌ی محدودِ تعریف‌شده در JSON):
- پیش‌شرط ضروری: `N >= 0`
- پیش‌شرط‌های زائد: `N <= 1000` ، `N >= -100` ، `M >= 0`
- نکته: در بررسی IC-like (صرفاً «استنتاج منطقی از سایر پیش‌شرط‌ها در دامنه محدود»)، پیش‌شرط `M >= 0` **نتیجه نمی‌شود** اما با حذفش همچنان قرارداد برقرار است؛ این دقیقاً همان نوع حالتی است که مقاله هم برای تفاوت IC و سایر روش‌ها مطرح می‌کند (وابستگی/معنا در برنامه، نه صرفاً استنتاج از پیش‌شرط‌ها).

### محدودیت‌ها
- این پیاده‌سازی یک **prototype آموزشی** است و به‌جای تحلیل کامل C و ابزارهایی مثل CPAchecker، از bounded execution استفاده می‌کند؛ بنابراین نتیجه‌ها «تضمین کامل برای همه‌ی ورودی‌ها» نیست مگر دامنه ورودی‌ها کامل باشد.

## 4) فرآیند اجرای پروژه
1. انتخاب مقاله مرجع و مطالعه (PDF مقاله + اسلاید).
2. استخراج تعاریف کلیدی (افزونگی تکی/گروهی، ایده‌ی روش‌های IC/DC/PC).
3. پیاده‌سازی یک prototype کوچک برای بازتولید ایده‌ی «حذف پیش‌شرط و بررسی دوباره» در قالب bounded checking.
4. اجرای ابزار روی مثال‌ها و ثبت نتایج.
5. آماده‌سازی گزارش و بسته‌ی نهایی زیپ.

## 5) کدهای پروژه / گیت‌هاب
- کد پروژه کوچک است و به‌صورت فایل‌های همین زیپ پیوست می‌شود.
- اگر لازم شد روی گیت‌هاب آپلود شود: **(لینک اینجا قرار گیرد)**.

## پیوست‌ها
- مقاله مرجع (PDF) و اسلایدها در فایل زیپ نهایی قرار داده می‌شوند.
