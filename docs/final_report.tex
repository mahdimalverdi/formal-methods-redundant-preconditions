% !TeX program = xelatex
\documentclass[
10pt,
a4paper,
oneside,
headinclude,footinclude,
BCOR5mm
]{scrartcl}

\usepackage{listings}
\usepackage{xcolor}

\input{arsclassica_structure_rtl.tex}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  columns=fullflexible,
  frame=single,
  rulecolor=\color{black!20}
}

\title{گزارش نهایی پروژه درس «روش‌های صوری»\\
\large \lr{Detecting Redundant Preconditions}\\
\normalsize خلاصه، پیاده‌سازی و شبیه‌سازی}
\author{مهدی مالوردی\thanks{\lr{Student number: 404443150}}}
\date{}

\begin{document}
\begin{RTL}
\setlength{\emergencystretch}{2em}
\maketitle

\section*{چکیده}
این گزارش مقاله‌ی \lr{Detecting Redundant Preconditions} را خلاصه می‌کند و یک پیاده‌سازی/شبیه‌سازی آموزشی برای بررسی افزونگی پیش‌شرط‌ها در یک دامنه‌ی محدود ارائه می‌دهد.
هدف، مشاهده‌ی تفاوت روش‌های مبتنی بر \lr{Implication} و \lr{Dependency} با روش «حذف پیش‌شرط و بررسی دوباره» در سناریوهای ساده است.

\textbf{کلمات کلیدی:} قراردادها، پیش‌شرط، افزونگی، \lr{Design by Contract}، روش‌های صوری

\section{خلاصه مقاله مرجع}
\textbf{عنوان:} \lr{Detecting Redundant Preconditions} \\
\textbf{نویسندگان:} \lr{Nicola Thoben, Heike Wehrheim} \\
\textbf{منبع:} \lr{FormaliSE 2025 (IEEE/ACM)} \\
\textbf{DOI:} \lr{\texttt{10.1109/FORMALISE66629.2025.00015}}

\subsection{هدف و دامنه}
مقاله روی «کیفیت قراردادها» تمرکز دارد، نه روی تولید قرارداد \lrpar{contract synthesis} و نه روی اعتبارسنجیِ صرف.
فرض مقاله این است که برنامه‌ها نسبت به قرارداد فعلی صحیح هستند و سؤال اصلی این است که آیا بخشی از پیش‌شرط‌ها واقعاً برای برقرار شدن پس‌شرط لازم هستند یا خیر.
نکته‌ی مهم مقاله این است که در برخی سناریوها—even اگر یک پیش‌شرط از نظر صحتِ پس‌شرط «لازم» نباشد—ممکن است از نظر مستندسازی یا تعریف دامنه‌ی ورودی‌های معتبر، نگه داشتن آن مطلوب باشد؛ با این حال کشفِ افزونگی می‌تواند قرارداد را ساده‌تر، خواناتر و قابل‌استفاده‌تر کند.

\subsection{پیش‌زمینه مفهومی}
\paragraph{قراردادها در \lr{Design by Contract}}
قرارداد تابع/ماژول معمولاً با \lr{Preconditions} و \lr{Postconditions} بیان می‌شود.
در مدل مقاله، پیش‌شرط‌ها و پس‌شرط‌ها به ترتیب به صورت \lr{\texttt{assume}} و \lr{\texttt{assert}} در ابتدای/انتهای برنامه (یا تابع بسته) قرار داده می‌شوند تا ابزارهای تحلیل/اثبات بتوانند آن‌ها را بررسی کنند.

\paragraph{نمودار جریان کنترل و تحلیل گزاره‌ای}
برای تحلیل، مقاله از مفاهیم رایج در راستی‌آزمایی نرم‌افزار استفاده می‌کند:
نمایش برنامه به صورت \lr{CFA} (نمودار جریان کنترل)، توسعه‌ی آن با یال‌های \lr{assume/assert} و مدل کردن نقضِ \lr{assert} با رسیدن به مکان خطا.
همچنین از \lr{predicate analysis} و \lr{CEGAR} (پالایش مبتنی بر ضدنمونه) برای ساخت \lr{ARG} (گراف دسترسی‌پذیری انتزاعی) استفاده می‌شود.

\subsection{تعریف رسمی افزونگی}
مقاله افزونگی را بر اساس «درستی برنامه نسبت به قرارداد» تعریف می‌کند:
\begin{itemize}
  \item \textbf{افزونگی تکی:} پیش‌شرط \lr{\texttt{pre\_i}} در مجموعه‌ی \lr{\texttt{Pre}} زائد است اگر با حذف آن همچنان برنامه پس‌شرط‌ها را برقرار کند.
  \item \textbf{افزونگی گروهی:} یک مجموعه از پیش‌شرط‌ها وقتی زائدِ گروهی است که بتوان همه‌ی آن‌ها را همزمان حذف کرد و قرارداد همچنان برقرار بماند.
\end{itemize}
این دو مفهوم مهم‌اند چون ممکن است هر پیش‌شرط به تنهایی «قابل حذف» باشد، ولی حذف همزمان چند پیش‌شرط باعث شکستن قرارداد شود (وابستگی بین پیش‌شرط‌ها/نقش‌شان در محدود کردن دامنه‌ی حالات اولیه).

\subsection{رویکرد ساده اما پرهزینه \lrpar{Baseline}}
تعریف افزونگی مستقیماً یک روش ساده پیشنهاد می‌کند: برای هر پیش‌شرط (یا مجموعه‌ای از آن‌ها) یک بار آن را حذف کنیم و دوباره با یک راستی‌آزما بررسی کنیم که آیا پس‌شرط‌ها هنوز اثبات می‌شوند یا نه.
مشکل: اجرای چندباره‌ی ابزارهای اثبات/راستی‌آزمایی برای هر برنامه بسیار پرهزینه است، بنابراین مقاله دنبال تکنیک‌های کاراتر است.

\subsection{تکنیک‌های پیشنهادی برای کشف افزونگی}
مقاله سه تکنیک با توازن متفاوت بین دقت و هزینه ارائه می‌دهد:

\subsubsection{۱) \lr{IC} — بررسی استنتاج منطقی \lrpar{Implication Checking}}
\begin{itemize}
  \item \textbf{ایده:} آیا \lr{\texttt{pre\_i}} از سایر پیش‌شرط‌ها نتیجه می‌شود؟
  \item \textbf{ورودی/خروجی:} فقط \lr{Pre}؛ خروجیِ هر پیش‌شرط: \lrpar{implied / not implied}.
  \item \textbf{نقطه‌ضعف:} افزونگیِ وابسته به رفتار برنامه را لزوماً نمی‌گیرد (مثل بسیاری از موارد \lr{Range}).
\end{itemize}

\subsubsection{۲) \lr{DC} — تحلیل وابستگی \lrpar{Dependency Calculation}}
\begin{itemize}
  \item \textbf{ایده:} اگر پیش‌شرط به هیچ پس‌شرطی (از منظر وابستگی داده/کنترل) نرسد، زائد فرض می‌شود.
  \item \textbf{ورودی/خروجی:} برنامه به‌صورت \lr{CFA} توسعه‌یافته + قرارداد؛ خروجی: پیش‌شرط‌های \lrpar{dependency-free}.
  \item \textbf{نقطه‌ضعف:} چون نحوی است، ممکن است افزونگی‌های معنایی را از دست بدهد.
\end{itemize}

\subsubsection{۳) \lr{PC} — تحلیل گزاره‌ای/انتزاعی \lrpar{Predicate Checking}}
\begin{itemize}
  \item \textbf{ایده:} اگر عبور از یالِ \lrcode{assume(b)} predicate را تقویت نکند، آن پیش‌شرط در این اثبات «لازم» نبوده است.
  \item \textbf{ورودی/خروجی:} تحلیل گزاره‌ای + \lr{CEGAR} برای ساخت \lr{ARG}؛ خروجی: پیش‌شرط‌هایی که \lr{precision} انتزاع را تغییر نمی‌دهند.
  \item \textbf{نقطه‌ضعف:} معمولاً پرهزینه‌تر از \lr{IC/DC} است.
\end{itemize}

\subsection{ارزیابی تجربی مقاله}
\paragraph{داده‌ها و بنچمارک}
برای ارزیابی، نویسندگان مجموعه‌ای از 62 برنامه \lr{C} را انتخاب می‌کنند (از منابع مختلف) و ابتدا با \lr{CPAchecker} بررسی می‌کنند که نسبت به قراردادهای موجود صحیح هستند.
سپس با سه نوع تبدیل، پیش‌شرط‌های زائد تزریق می‌کنند:
\begin{itemize}
  \item \textbf{Type 1 \lrpar{Independency}:} معرفی متغیر/قید اضافی که در صحت پس‌شرط نقشی ندارد.
  \item \textbf{Type 2 \lrpar{Implication}:} ساخت قیدی که توسط یک پیش‌شرط لازم دیگر نتیجه می‌شود (با کمک حل‌کننده‌ی \lr{Eldarica}).
  \item \textbf{Type 3 \lrpar{Range}:} افزودن کرانِ «جهت مخالف» برای متغیری که یک کران لازم دارد (مثلاً اگر \lr{\texttt{x > 0}} لازم است، \lr{\texttt{x < 100}} اضافه می‌شود) تا قید بازه‌ای بسازد که از نظر صحت پس‌شرط زائد است.
\end{itemize}

\paragraph{فرضیه‌ها}
مقاله سه فرضیه مطرح می‌کند:
\begin{itemize}
  \item \textbf{H1 (اثربخشی):} \lr{IC} و \lr{DC} قابل‌مقایسه‌ی ساده نیستند و \lr{PC} باید از هر دو بهتر باشد.
  \item \textbf{H2 (کامل بودن):} انتظار می‌رود \lr{PC} (در صورت اتمام \lr{CEGAR}) کامل باشد، اما نتایج تجربی خلاف این را نشان می‌دهد.
  \item \textbf{H3 (کارایی):} \lr{IC/DC} بسیار سبک‌تر از \lr{PC} هستند.
\end{itemize}

\paragraph{نتیجه‌های اصلی}
در آزمایش‌های مقاله، \lr{PC} بیشترین تعداد پیش‌شرط‌های زائد را تشخیص می‌دهد (به‌خصوص در نوع \lr{Range}) ولی از نظر کامل بودن در پیاده‌سازی \lr{CPAchecker} بی‌نقص نیست.
همچنین \lr{PC} از نظر زمان/حافظه پرهزینه‌تر از روش‌های مبتنی بر \lr{CFA} است، در حالی که \lr{IC} و \lr{DC} بسیار سریع‌ترند.

\subsection{جمع‌بندی و کارهای آینده (طبق مقاله)}
مقاله سه تکنیک عملی برای کشف افزونگی پیش‌شرط‌ها ارائه می‌دهد و نشان می‌دهد بین سرعت و دقت یک trade-off جدی وجود دارد.
به عنوان کار آینده، توسعه‌ی روش‌هایی برای کشف «روابط علّی» بین پیش‌شرط‌ها و پس‌شرط‌ها و همچنین استفاده از \lr{ACSL} برای نوشتن قراردادها پیشنهاد می‌شود.
در بسته‌ی پروژه، فایل PDF مقاله مرجع نیز پیوست شده است تا خواننده در صورت نیاز به جزئیات کامل، مستقیماً به متن اصلی مراجعه کند.

\section{نوآوری این پروژه (افزونگی گروهی با شاهد نقض)}
\begin{itemize}
  \item \textbf{ایده/نوآوری:} علاوه بر تشخیص \textbf{افزونگی تکی}، یک ماژول \textbf{افزونگی گروهی} اضافه شده است که وقتی مجموعه‌ای از پیش‌شرط‌ها به صورت تکی زائد هستند اما حذف همزمان آن‌ها قرارداد را می‌شکند، یک \textbf{شاهد نقض} (ورودی مشخص) تولید می‌کند.
  \item \textbf{چراییِ ارزشمند بودن:} این کار، خروجی را از یک برچسب ساده‌ی «زائد/غیرزائد» به یک نتیجه‌ی \lr{explainable} تبدیل می‌کند و برای ارائه/دیباگ قراردادها بسیار قابل استفاده است.
  \item \textbf{جزئیات پیاده‌سازی:} ابزار این موارد را محاسبه می‌کند:
  \begin{itemize}
    \item مجموعه‌ی پیش‌شرط‌های \textbf{single-redundant}،
    \item یک مجموعه‌ی \textbf{group-redundant} (با حذف حریصانه)،
    \item و در صورت عدم افزونگی گروهی، \textbf{counterexample input}.
  \end{itemize}
  \item \textbf{مثال ارائه‌ای \lrpar{Counterexample}:} در فایل \lr{\url{examples/group_redundancy.json}} هر سه پیش‌شرط به صورت تکی زائد هستند، اما حذف همزمان همه‌ی آن‌ها قرارداد را می‌شکند و ابزار یک شاهد نقض مانند \lr{\texttt{a=-2, b=-2}} تولید می‌کند.
  \newline \textbf{خروجی:} \lr{\url{outputs/group_redundancy_report.json}}.
\end{itemize}

\paragraph{نمونه‌ی خروجی (خلاصه)}
\begin{latin}
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
single_redundant_indices: [0, 1, 2]
all_single_is_group_redundant: false
counterexample_if_not_group: {"a": -2, "b": -2}
\end{lstlisting}
\end{latin}

\section{پیاده‌سازی و نتایج اجرای کد}
\subsection{توضیح پیاده‌سازی}
فایل \lr{\texttt{fm\_project/redundancy\_checker.py}} یک ابزار ساده است که:
\begin{itemize}
  \item یک برنامه‌ی کوچک را از روی فایل JSON می‌خواند (شامل \lr{\texttt{pre}}، \lr{\texttt{post}} و بدنه‌ی برنامه با \lr{\texttt{assign/while/if}}).
  \item ورودی‌ها را در یک بازه‌ی محدود \lrpar{bounded domain} شمارش \lrpar{enumerate} می‌کند.
  \item صحت قرارداد را در این دامنه بررسی می‌کند.
  \item برای هر پیش‌شرط، با حذف آن و اجرای دوباره، افزونگی تکی را بررسی می‌کند.
  \item یک بررسی \lr{IC-like} هم انجام می‌دهد: آیا پیش‌شرط از بقیه‌ی پیش‌شرط‌ها (در همان دامنه محدود) نتیجه می‌شود یا نه.
\end{itemize}

\subsection{نتایج نمونه}
نمونه‌ی \lr{\texttt{examples/sub.json}} نسخه‌ی ساده‌شده‌ی مثال مقاله/اسلاید است (متغیرهای \lr{\texttt{N}} و \lr{\texttt{M}} و حلقه).

\textbf{دستور اجرا:}
\begin{latin}
\begin{lstlisting}
.venv/bin/python main.py --spec examples/sub.json
\end{lstlisting}
\end{latin}

\textbf{خروجی اجرا:}
خروجی دقیقِ اجرا در فایل \lr{\url{outputs/sub_run.txt}} ذخیره شده است. خلاصه‌ی نتیجه روی این مثال (در دامنه‌ی محدودِ تعریف‌شده در JSON):
\begin{itemize}
  \item پیش‌شرط ضروری: \lr{\texttt{N >= 0}}
  \item پیش‌شرط‌های زائد: \lr{\texttt{N <= 1000}} ، \lr{\texttt{N >= -100}} ، \lr{\texttt{M >= 0}}
  \item نکته: در بررسی \lr{IC-like}، پیش‌شرط \lr{\texttt{M >= 0}} نتیجه نمی‌شود اما با حذفش همچنان قرارداد برقرار است؛ این دقیقاً نمونه‌ای از تفاوت «استنتاج از پیش‌شرط‌ها» با «لازم بودن برای برنامه» است.
\end{itemize}

\subsection{مثال دوم: افزونگی بازه‌ای \lrpar{Range} بدون استنتاج}
برای نمایش یک حالتِ ارائه‌ای که در آن پیش‌شرطی زائد است ولی از سایر پیش‌شرط‌ها نتیجه نمی‌شود، از مثال \lr{\url{examples/range_redundancy.json}} استفاده شد.

\textbf{دستور اجرا:}
\begin{latin}
\begin{lstlisting}
.venv/bin/python main.py --spec examples/range_redundancy.json
\end{lstlisting}
\end{latin}

\textbf{خلاصه خروجی:} (فایل کامل: \lr{\url{outputs/range_redundancy_run.txt}})
\begin{itemize}
  \item \lr{\texttt{N <= 3}} \textbf{زائد} تشخیص داده می‌شود، اما در \lr{IC-like} به عنوان «\lr{NOT implied}» گزارش می‌شود.
  \item این مثال نشان می‌دهد چرا روش‌هایی مثل \lr{IC} (صرفاً استنتاج از پیش‌شرط‌ها) برای پوشش همه حالت‌های افزونگی کافی نیستند و باید سراغ روش‌های معنایی‌تر رفت (مثل حذف و بررسی مجدد قرارداد یا روش‌های مبتنی بر تحلیل برنامه).
\end{itemize}

\subsection{خلاصه‌ی نتایج روی مثال‌ها (قابل ارائه)}
خلاصه‌ی نتایج روی چند مثال اصلی و چند مثال «واقع‌گرایانه» در جدول~\ref{tab:example-results} آمده است. (خروجی کاملِ هر مثال در مسیر \lr{\url{outputs/}} موجود است.)
\begin{table}[tb]
\centering
\small
\setlength{\tabcolsep}{4pt}
\renewcommand{\arraystretch}{1.15}
\begin{LTR}
\begin{tabular}{lrrrrl}
\toprule
\RL{مثال} & \#Pre & Needed & Redundant & \#IC-implied & \RL{شاهد نقض} \\
\midrule
\lr{\texttt{sub}} & 4 & 1 & 3 & 2 & --- \\
\lr{\texttt{range}} & 3 & 1 & 2 & 0 & --- \\
\lr{\texttt{group}} & 3 & 0 & 3 & 3 & \lr{\texttt{a=-2,b=-2}} \\
\midrule
\lr{\texttt{gen-001}} & 4 & 1 & 3 & 3 & --- \\
\lr{\texttt{gen-015}} & 4 & 1 & 3 & 3 & --- \\
\lr{\texttt{gen-034}} & 4 & 0 & 4 & 4 & --- \\
\bottomrule
\end{tabular}
\end{LTR}
\caption{خلاصه‌ی نتایج روی مثال‌ها (در دامنه‌ی محدودِ تعریف‌شده در هر JSON)}
\label{tab:example-results}
\end{table}
\noindent\textbf{راهنما:}
\begin{itemize}
  \item \lr{\texttt{sub}}: \lr{\texttt{examples/sub.json}}
  \item \lr{\texttt{range}}: \lr{\texttt{examples/range\_redundancy.json}}
  \item \lr{\texttt{group}}: \lr{\texttt{examples/group\_redundancy.json}}
  \item \lr{\texttt{gen-001}}: \lr{\texttt{examples/generated/ex\_001.json}} (به همین ترتیب برای سایر \lr{\texttt{gen-***}})
\end{itemize}

\subsection{مجموعه مثال‌های واقع‌گرایانه (100 مثال)}
برای اینکه نتایج ابزار فقط محدود به چند مثالِ خیلی کوچک نباشد و مثال‌ها «شبیه ورودی‌های واقعی یک انسان» باشند، مجموعه‌ای از 100 مثال متنوع تولید شد که هر کدام داستان/سناریوی کوتاهی دارد (مثل \lr{clamp} کردن سنسور، اعتبارسنجی بازه، \lr{swap} بازه، جمع 1 تا N، باقی‌مانده با تفریق تکراری و ...).
این مثال‌ها در مسیر \lr{\url{examples/generated/}} قرار دارند و در فایل زیپ نهایی نیز پیوست شده‌اند.

\paragraph{آمار کلی روی مجموعه مثال‌ها}
برای اینکه این مجموعه صرفاً «پیوست» نباشد، روی کل 100 مثال اجرا انجام شد و خلاصه‌ی نتایج در فایل \lr{\url{outputs/generated_examples_summary.txt}} ذخیره گردید.
طبق این خروجی:
\begin{itemize}
  \item میانگین تعداد پیش‌شرط‌ها در هر مثال: 4.00
  \item میانگین پیش‌شرط‌های ضروری: 0.23 (در 23 مثال حداقل یک پیش‌شرط ضروری وجود دارد)
  \item میانگین پیش‌شرط‌های زائد: 3.77 (در 77 مثال همه‌ی پیش‌شرط‌ها زائد تشخیص داده می‌شوند)
  \item میانگین پیش‌شرط‌های \lr{IC-like implied}: 3.46
\end{itemize}
این اعداد با هدف آموزشیِ این پروژه سازگارند: مثال‌ها طوری طراحی شده‌اند که ابزار بتواند تفاوت روش‌ها را در الگوهای مختلف (به‌خصوص \lr{Range} و \lr{Independency}) نشان دهد.

\textbf{تولید/بازسازی مثال‌ها:}
\begin{latin}
\begin{lstlisting}
.venv/bin/python -m tools.generate_examples --count 100 --seed 7 --out_dir examples/generated --validate --overwrite
\end{lstlisting}
\end{latin}

\textbf{محاسبه‌ی همین آمار:}
\begin{latin}
\begin{lstlisting}
.venv/bin/python -m tools.summarize_generated_examples
\end{lstlisting}
\end{latin}

\subsection{محدودیت‌ها}
این پیاده‌سازی یک \textbf{prototype آموزشی} است و به‌جای تحلیل کامل \lr{C} و ابزارهایی مثل \lr{CPAchecker}، از \lr{bounded execution} استفاده می‌کند؛ بنابراین:
\begin{itemize}
  \item نتیجه‌ها فقط برای دامنه‌ی ورودیِ تعریف‌شده در JSON معتبرند (ممکن است بیرون دامنه، افزونگی/غیرافزونگی تغییر کند).
  \item حدّ گام \lrpar{step\_limit} می‌تواند باعث گزارش‌های کاذبِ «نقض/عدم پایان» شود اگر دامنه یا حدّ گام مناسب انتخاب نشود.
  \item زبان برنامه/گزاره‌ها کوچک است (بدون فراخوانی تابع/حافظه/تقسیم) و تحلیل‌ها جایگزین روش‌های صنعتی مقاله نیستند.
\end{itemize}

\section{شبیه‌سازی}
برای مقایسه‌ی ایده‌های مقاله به‌صورت آموزشی، یک شبیه‌سازی کوچک روی مجموعه‌ای از برنامه‌های مصنوعی انجام شد.
در هر برنامه یک پیش‌شرط ضروری و سه پیش‌شرط زائد از سه نوعِ \textbf{Independency}، \textbf{Implication} و \textbf{Range} تزریق شد و سه روش زیر مقایسه شدند:
\begin{itemize}
  \item \lr{IC-like}: بررسی استنتاج منطقی از سایر پیش‌شرط‌ها
  \item \lr{DC-like}: تحلیل وابستگی نحوی از متغیرهای پس‌شرط
  \item \lr{VC}: حذف پیش‌شرط و بررسی مجدد قرارداد (روش معنایی در دامنه محدود، نقشِ baseline)
\end{itemize}

\noindent\textbf{نکته:} در این benchmark، سه پیش‌شرطِ زائد «به‌صورت تزریق‌شده/طراحی‌شده» هستند و به همین دلیل انتظار می‌رود روش \lr{VC} همه‌ی آن‌ها را کشف کند (چون تعریف افزونگی را به‌طور مستقیم در دامنه محدود چک می‌کند). هدف این بخش، نشان دادن این است که روش‌های \lr{IC-like} و \lr{DC-like} به‌صورت سیستماتیک بعضی الگوها (مثل \lr{Range}) را از دست می‌دهند.

این شبیه‌سازی با دستور زیر اجرا شد و خروجی در \lr{\url{outputs/simulation_summary.txt}} ذخیره گردید:
\begin{latin}
\begin{lstlisting}
.venv/bin/python main.py --simulate --sim_n=39 --sim_seed=1
\end{lstlisting}
\end{latin}

نتیجه‌ی شبیه‌سازی (39 برنامه، مجموع 117 پیش‌شرط زائد) در جدول~\ref{tab:simulation-results} آمده است:
\begin{table}[tb]
\centering
\small
\begin{LTR}
\begin{tabular}{lrrrr}
\toprule
\RL{نوع پیش‌شرط زائد} & \RL{تعداد واقعی} & \lr{IC-like} & \lr{DC-like} & \lr{VC} \\
\midrule
\lr{Independency} & 39 & 0 & 39 & 39 \\
\lr{Implication}  & 39 & 39 & 0 & 39 \\
\lr{Range}        & 39 & 0 & 0 & 39 \\
\midrule
\lr{Total}        & 117 & 39 & 39 & 117 \\
\bottomrule
\end{tabular}
\end{LTR}
\caption{نتیجه‌ی شبیه‌سازی آموزشی روی 39 برنامه (شمارشِ پیش‌شرط‌های زائدِ تزریق‌شده که توسط هر روش کشف شده‌اند)}
\label{tab:simulation-results}
\end{table}

\section{فرآیند اجرای پروژه (نحوه اجرای کدها و بازتولید نتایج)}
\textbf{پیش‌نیاز:} \lr{Python 3.12} و دسترسی به یک محیط \lr{Linux} (یا مشابه).
\begin{enumerate}
  \item \textbf{ساخت محیط و نصب وابستگی‌ها:}
  \begin{latin}
  \begin{lstlisting}
python3.12 -m venv .venv
. .venv/bin/activate
pip install -r requirements.txt
  \end{lstlisting}
  \end{latin}

  \item \textbf{اجرای مثال‌های اصلی (تولید خروجی‌های پوشه \lr{\url{outputs/}}):}
  \begin{latin}
  \begin{lstlisting}
.venv/bin/python main.py --spec examples/sub.json
.venv/bin/python main.py --spec examples/range_redundancy.json
.venv/bin/python main.py --spec examples/group_redundancy.json --group
  \end{lstlisting}
  \end{latin}

  \item \textbf{اجرای شبیه‌سازی:}
  \begin{latin}
  \begin{lstlisting}
.venv/bin/python main.py --simulate --sim_n=39 --sim_seed=1
  \end{lstlisting}
  \end{latin}

  \item \textbf{آمارگیری از مثال‌های تولیدی:}
  \begin{latin}
  \begin{lstlisting}
.venv/bin/python -m tools.summarize_generated_examples
  \end{lstlisting}
  \end{latin}

  \item \textbf{ساخت PDF گزارش:}
  \begin{latin}
  \begin{lstlisting}
tools/bin/tectonic -X compile --outdir docs docs/final_report.tex
  \end{lstlisting}
  \end{latin}

  \item \textbf{ساخت فایل زیپ تحویل:}
  \begin{latin}
  \begin{lstlisting}
.venv/bin/python make_submission_zip.py MahdiMalverdi 404443150
  \end{lstlisting}
  \end{latin}
\end{enumerate}
\noindent\textbf{نکته:} این پروژه تستِ واحد \lrpar{unit test} جداگانه ندارد؛ «تست» در اینجا به معنی اجرای مثال‌ها و بازتولید خروجی‌های ثبت‌شده است.

\section{کدهای پروژه / گیت‌هاب}
\begin{itemize}
  \item کد پروژه کوچک است و به‌صورت فایل‌های همین زیپ پیوست می‌شود.
  \item مخزن گیت‌هاب: \lr{\url{https://github.com/mahdimalverdi/formal-methods-redundant-preconditions}}
\end{itemize}

\section{پیوست‌ها}
\begin{itemize}
  \item مقاله مرجع (PDF) و اسلایدها در فایل زیپ نهایی قرار داده می‌شوند.
  \item توجه: فایل‌های PDF خارجی (مقاله/اسلاید) در گیت‌هاب نگه‌داری نشده‌اند و فقط در بسته‌ی زیپ ارائه می‌شوند.
\end{itemize}

\section*{منابع}
\begin{enumerate}
  \item \lr{N. Thoben, H. Wehrheim, ``Detecting Redundant Preconditions,'' FormaliSE 2025, DOI: 10.1109/FORMALISE66629.2025.00015.}
\end{enumerate}

\end{RTL}
\end{document}
