% !TeX program = xelatex
\documentclass[
10pt,
a4paper,
oneside,
headinclude,footinclude,
BCOR5mm
]{scrartcl}

\usepackage{listings}
\usepackage{xcolor}

\input{arsclassica_structure_rtl.tex}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  columns=fullflexible,
  frame=single,
  rulecolor=\color{black!20}
}

\title{گزارش نهایی پروژه درس «روش‌های صوری»\\
\large \lr{Detecting Redundant Preconditions}\\
\normalsize خلاصه، پیاده‌سازی و شبیه‌سازی}
\author{مهدی مالوردی\thanks{\lr{Student number: 404443150}}}
\date{}

\begin{document}
\begin{RTL}
\setlength{\emergencystretch}{2em}
\maketitle

\section*{چکیده}
این گزارش مقاله‌ی \lr{Detecting Redundant Preconditions} را خلاصه می‌کند و یک پیاده‌سازی/شبیه‌سازی آموزشی برای بررسی افزونگی پیش‌شرط‌ها در یک دامنه‌ی محدود ارائه می‌دهد.
هدف، مشاهده‌ی تفاوت روش‌های مبتنی بر \lr{Implication} و \lr{Dependency} با روش «حذف پیش‌شرط و بررسی دوباره» در سناریوهای ساده است.

\textbf{کلمات کلیدی:} قراردادها، پیش‌شرط، افزونگی، \lr{Design by Contract}، روش‌های صوری

\section{خلاصه مقاله مرجع}
\textbf{عنوان:} \lr{Detecting Redundant Preconditions} \\
\textbf{نویسندگان:} \lr{Nicola Thoben, Heike Wehrheim} \\
\textbf{منبع:} \lr{FormaliSE 2025 (IEEE/ACM)} \\
\textbf{DOI:} \lr{\texttt{10.1109/FORMALISE66629.2025.00015}}

\subsection{هدف و دامنه}
مقاله روی «کیفیت قراردادها» تمرکز دارد، نه روی تولید قرارداد (\lr{contract synthesis}) و نه روی اعتبارسنجیِ صرف.
فرض مقاله این است که برنامه‌ها نسبت به قرارداد فعلی صحیح هستند و سؤال اصلی این است که آیا بخشی از پیش‌شرط‌ها واقعاً برای برقرار شدن پس‌شرط لازم هستند یا خیر.
نکته‌ی مهم مقاله این است که در برخی سناریوها—even اگر یک پیش‌شرط از نظر صحتِ پس‌شرط «لازم» نباشد—ممکن است از نظر مستندسازی یا تعریف دامنه‌ی ورودی‌های معتبر، نگه داشتن آن مطلوب باشد؛ با این حال کشفِ افزونگی می‌تواند قرارداد را ساده‌تر، خواناتر و قابل‌استفاده‌تر کند.

\subsection{پیش‌زمینه مفهومی}
\paragraph{قراردادها در \lr{Design by Contract}}
قرارداد تابع/ماژول معمولاً با \lr{Preconditions} و \lr{Postconditions} بیان می‌شود.
در مدل مقاله، پیش‌شرط‌ها و پس‌شرط‌ها به ترتیب به صورت \lr{\texttt{assume}} و \lr{\texttt{assert}} در ابتدای/انتهای برنامه (یا تابع بسته) قرار داده می‌شوند تا ابزارهای تحلیل/اثبات بتوانند آن‌ها را بررسی کنند.

\paragraph{نمودار جریان کنترل و تحلیل گزاره‌ای}
برای تحلیل، مقاله از مفاهیم رایج در راستی‌آزمایی نرم‌افزار استفاده می‌کند:
نمایش برنامه به صورت \lr{CFA} (نمودار جریان کنترل)، توسعه‌ی آن با یال‌های \lr{assume/assert} و مدل کردن نقضِ \lr{assert} با رسیدن به مکان خطا.
همچنین از \lr{predicate analysis} و \lr{CEGAR} (پالایش مبتنی بر ضدنمونه) برای ساخت \lr{ARG} (گراف دسترسی‌پذیری انتزاعی) استفاده می‌شود.

\subsection{تعریف رسمی افزونگی}
مقاله افزونگی را بر اساس «درستی برنامه نسبت به قرارداد» تعریف می‌کند:
\begin{itemize}
  \item \textbf{افزونگی تکی:} پیش‌شرط \lr{\texttt{pre\_i}} در مجموعه‌ی \lr{\texttt{Pre}} زائد است اگر با حذف آن همچنان برنامه پس‌شرط‌ها را برقرار کند.
  \item \textbf{افزونگی گروهی:} یک مجموعه از پیش‌شرط‌ها وقتی زائدِ گروهی است که بتوان همه‌ی آن‌ها را همزمان حذف کرد و قرارداد همچنان برقرار بماند.
\end{itemize}
این دو مفهوم مهم‌اند چون ممکن است هر پیش‌شرط به تنهایی «قابل حذف» باشد، ولی حذف همزمان چند پیش‌شرط باعث شکستن قرارداد شود (وابستگی بین پیش‌شرط‌ها/نقش‌شان در محدود کردن دامنه‌ی حالات اولیه).

\subsection{رویکرد ساده اما پرهزینه (Baseline)}
تعریف افزونگی مستقیماً یک روش ساده پیشنهاد می‌کند: برای هر پیش‌شرط (یا مجموعه‌ای از آن‌ها) یک بار آن را حذف کنیم و دوباره با یک راستی‌آزما بررسی کنیم که آیا پس‌شرط‌ها هنوز اثبات می‌شوند یا نه.
مشکل: اجرای چندباره‌ی ابزارهای اثبات/راستی‌آزمایی برای هر برنامه بسیار پرهزینه است، بنابراین مقاله دنبال تکنیک‌های کاراتر است.

\subsection{تکنیک‌های پیشنهادی برای کشف افزونگی}
مقاله سه تکنیک با توازن متفاوت بین دقت و هزینه ارائه می‌دهد:

\paragraph{۱) \lr{IC} — بررسی استنتاج منطقی (\lr{Implication Checking})}
در این روش خودِ پیش‌شرط‌ها با هم مقایسه می‌شوند و برنامه/پس‌شرط به‌صورت مستقیم وارد تحلیل نمی‌شود.
ایده: اگر یک پیش‌شرط از ترکیب سایر پیش‌شرط‌ها نتیجه شود، در حضور آن‌ها اضافه است.
مقاله همچنین توضیح می‌دهد که افزونگی تکی لزوماً به افزونگی گروهی تبدیل نمی‌شود؛ برای همین یک رویه‌ی تکراری برای بررسی حذف گروهیِ پیش‌شرط‌های «قابل‌نتیجه‌گیری» ارائه می‌کند.

\paragraph{۲) \lr{DC} — تحلیل وابستگی (\lr{Dependency Calculation})}
در این روش، برنامه به صورت \lr{CFA} توسعه‌یافته (با یال‌های \lr{assume/assert} و مکان خطا) مدل می‌شود و سپس وابستگی‌های داده/کنترل بین پیش‌شرط‌ها و پس‌شرط‌ها بررسی می‌شود.
اگر یک پیش‌شرط به هیچ پس‌شرطی (از منظر وابستگی نحوی) وابسته نباشد، می‌توان آن را زائد فرض کرد.
این روش سریع است، اما چون صرفاً وابستگی‌های \textbf{نحوی} را می‌بیند، ممکن است پیش‌شرطی که وابستگی نحوی دارد ولی از نظر معنایی لازم نیست را زائد تشخیص ندهد.

\paragraph{۳) \lr{PC} — تحلیل گزاره‌ای/انتزاعی (\lr{Predicate Checking})}
این روش یک بار تحلیل گزاره‌ای را اجرا می‌کند تا \lr{ARG} ساخته شود.
ایده‌ی کلیدی: اگر در یال متناظر با یک پیش‌شرط (\lr{\texttt{assume(b)}})، گزاره‌ی انتزاعی قبل و بعد از آن تغییری نکند (یعنی اضافه شدن آن پیش‌شرط در محاسبه‌ی انتزاع اثر نگذارد)، آن پیش‌شرط در این اثبات «لازم» نبوده و می‌تواند زائد باشد.
مقاله برای نسخه‌ی مبتنی بر \lr{ARG} یک قضیه‌ی صحت (\lr{soundness}) بیان می‌کند: اگر عبور از یالِ \lr{assume} موجب تقویت predicate نشود، جایگزینی آن با \lr{\texttt{assume(true)}} همچنان شواهد کافی برای صحت قرارداد را حفظ می‌کند.

\subsection{ارزیابی تجربی مقاله}
\paragraph{داده‌ها و بنچمارک}
برای ارزیابی، نویسندگان مجموعه‌ای از 62 برنامه \lr{C} را انتخاب می‌کنند (از منابع مختلف) و ابتدا با \lr{CPAchecker} بررسی می‌کنند که نسبت به قراردادهای موجود صحیح هستند.
سپس با سه نوع تبدیل، پیش‌شرط‌های زائد تزریق می‌کنند:
\begin{itemize}
  \item \textbf{Type 1 (Independency):} معرفی متغیر/قید اضافی که در صحت پس‌شرط نقشی ندارد.
  \item \textbf{Type 2 (Implication):} ساخت قیدی که توسط یک پیش‌شرط لازم دیگر نتیجه می‌شود (با کمک حل‌کننده‌ی \lr{Eldarica}).
  \item \textbf{Type 3 (Range):} افزودن کرانِ «جهت مخالف» برای متغیری که یک کران لازم دارد (مثلاً اگر \lr{\texttt{x > 0}} لازم است، \lr{\texttt{x < 100}} اضافه می‌شود) تا قید بازه‌ای بسازد که از نظر صحت پس‌شرط زائد است.
\end{itemize}

\paragraph{فرضیه‌ها}
مقاله سه فرضیه مطرح می‌کند:
\begin{itemize}
  \item \textbf{H1 (اثربخشی):} \lr{IC} و \lr{DC} قابل‌مقایسه‌ی ساده نیستند و \lr{PC} باید از هر دو بهتر باشد.
  \item \textbf{H2 (کامل بودن):} انتظار می‌رود \lr{PC} (در صورت اتمام \lr{CEGAR}) کامل باشد، اما نتایج تجربی خلاف این را نشان می‌دهد.
  \item \textbf{H3 (کارایی):} \lr{IC/DC} بسیار سبک‌تر از \lr{PC} هستند.
\end{itemize}

\paragraph{نتیجه‌های اصلی}
در آزمایش‌های مقاله، \lr{PC} بیشترین تعداد پیش‌شرط‌های زائد را تشخیص می‌دهد (به‌خصوص در نوع \lr{Range}) ولی از نظر کامل بودن در پیاده‌سازی \lr{CPAchecker} بی‌نقص نیست.
همچنین \lr{PC} از نظر زمان/حافظه پرهزینه‌تر از روش‌های مبتنی بر \lr{CFA} است، در حالی که \lr{IC} و \lr{DC} بسیار سریع‌ترند.

\subsection{جمع‌بندی و کارهای آینده (طبق مقاله)}
مقاله سه تکنیک عملی برای کشف افزونگی پیش‌شرط‌ها ارائه می‌دهد و نشان می‌دهد بین سرعت و دقت یک trade-off جدی وجود دارد.
به عنوان کار آینده، توسعه‌ی روش‌هایی برای کشف «روابط علّی» بین پیش‌شرط‌ها و پس‌شرط‌ها و همچنین استفاده از \lr{ACSL} برای نوشتن قراردادها پیشنهاد می‌شود.
در بسته‌ی پروژه، فایل PDF مقاله مرجع نیز پیوست شده است تا خواننده در صورت نیاز به جزئیات کامل، مستقیماً به متن اصلی مراجعه کند.

\subsection{مسئله}
در «Design by Contract» قراردادها معمولاً با مجموعه‌ای از پیش‌شرط‌ها (Preconditions) و پس‌شرط‌ها (Postconditions) نوشته می‌شوند.
هدف مقاله بررسی کیفیت قراردادهاست: آیا برخی پیش‌شرط‌ها \textbf{زائد} هستند (یعنی حتی بدون آن‌ها هم پس‌شرط‌ها برقرار می‌مانند)؟

\subsection{تعریف افزونگی (Redundancy)}
یک پیش‌شرط \lr{\texttt{pre\_i}} در مجموعه \lr{\texttt{Pre}} زائد است اگر برنامه با حذف آن پیش‌شرط، همچنان قرارداد را ارضا کند (به‌صورت \lr{\texttt{P |= (Pre \{pre\_i\}, Post)}}).
مقاله علاوه بر افزونگی تکی، مفهوم \textbf{افزونگی گروهی} \lr{(group-redundant)} را هم تعریف می‌کند.

\subsection{روش‌های پیشنهادی مقاله}
مقاله سه تکنیک برای کشف پیش‌شرط‌های زائد ارائه می‌کند:
\begin{enumerate}
  \item \textbf{IC \lr{(Implication Checking)}:} بررسی می‌کند آیا \lr{\texttt{pre\_i}} به‌صورت منطقی از بقیه‌ی پیش‌شرط‌ها نتیجه می‌شود یا نه.
  \item \textbf{DC \lr{(Dependency Calculation)}:} روی CFA توسعه‌یافته، وابستگی‌های داده/کنترل بین \lr{\texttt{assume}}ها و \lr{\texttt{assert}}ها را بررسی می‌کند؛ اگر پیش‌شرط به هیچ پس‌شرطی وابسته نباشد، زائد است (روش نحوی/سینتکتیک).
  \item \textbf{PC \lr{(Predicate Checking)}:} با \lr{predicate analysis} و \lr{CEGAR} و ساخت \lr{ARG} بررسی می‌کند آیا در یالِ \lr{\texttt{assume(b)}}، predicate بعد از آن تغییر/تقویت می‌شود یا نه؛ اگر تقویت نشود، آن پیش‌شرط زائد است.
\end{enumerate}

\subsection{نتایج تجربی مقاله (خیلی خلاصه)}
روی 62 برنامه C و 155 پیش‌شرط زائد تزریق‌شده:
\begin{itemize}
  \item \lr{IC: 61/155}
  \item \lr{DC: 62/155}
  \item \lr{PC: 147/155}
\end{itemize}
همچنین PC منابع بیشتری (زمان/حافظه) مصرف می‌کند.

\section{نوآوری این پروژه (افزونگی گروهی با شاهد نقض)}
\begin{itemize}
  \item \textbf{ایده/نوآوری:} علاوه بر تشخیص \textbf{افزونگی تکی}، یک ماژول \textbf{افزونگی گروهی} اضافه شده است که وقتی مجموعه‌ای از پیش‌شرط‌ها به صورت تکی زائد هستند اما حذف همزمان آن‌ها قرارداد را می‌شکند، یک \textbf{شاهد نقض} (ورودی مشخص) تولید می‌کند.
  \item \textbf{چراییِ ارزشمند بودن:} این کار، خروجی را از یک برچسب ساده‌ی «زائد/غیرزائد» به یک نتیجه‌ی \lr{explainable} تبدیل می‌کند و برای ارائه/دیباگ قراردادها بسیار قابل استفاده است.
  \item \textbf{جزئیات پیاده‌سازی:} ابزار این موارد را محاسبه می‌کند:
  \begin{itemize}
    \item مجموعه‌ی پیش‌شرط‌های \textbf{single-redundant}،
    \item یک مجموعه‌ی \textbf{group-redundant} (با حذف حریصانه)،
    \item و در صورت عدم افزونگی گروهی، \textbf{counterexample input}.
  \end{itemize}
  \item \textbf{مثال ارائه‌ای (Counterexample):} در فایل \lr{\url{examples/group_redundancy.json}} هر سه پیش‌شرط به صورت تکی زائد هستند، اما حذف همزمان همه‌ی آن‌ها قرارداد را می‌شکند و ابزار یک شاهد نقض مانند \lr{\texttt{a=-2, b=-2}} تولید می‌کند.
  \newline \textbf{خروجی:} \lr{\url{outputs/group_redundancy_report.json}}.
\end{itemize}

\paragraph{نمونه‌ی خروجی (خلاصه)}
\begin{latin}
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
single_redundant_indices: [0, 1, 2]
all_single_is_group_redundant: false
counterexample_if_not_group: {"a": -2, "b": -2}
\end{lstlisting}
\end{latin}

\section{پیاده‌سازی و نتایج اجرای کد}
\subsection{توضیح پیاده‌سازی}
فایل \lr{\texttt{fm\_project/redundancy\_checker.py}} یک ابزار ساده است که:
\begin{itemize}
  \item یک برنامه‌ی کوچک را از روی فایل JSON می‌خواند (شامل \lr{\texttt{pre}}، \lr{\texttt{post}} و بدنه‌ی برنامه با \lr{\texttt{assign/while/if}}).
  \item ورودی‌ها را در یک بازه‌ی محدود (\lr{bounded domain}) شمارش (enumerate) می‌کند.
  \item صحت قرارداد را در این دامنه بررسی می‌کند.
  \item برای هر پیش‌شرط، با حذف آن و اجرای دوباره، افزونگی تکی را بررسی می‌کند.
  \item یک بررسی \lr{IC-like} هم انجام می‌دهد: آیا پیش‌شرط از بقیه‌ی پیش‌شرط‌ها (در همان دامنه محدود) نتیجه می‌شود یا نه.
\end{itemize}

\subsection{نتایج نمونه (Example)}
نمونه‌ی \lr{\texttt{examples/sub.json}} نسخه‌ی ساده‌شده‌ی مثال مقاله/اسلاید است (متغیرهای \lr{\texttt{N}} و \lr{\texttt{M}} و حلقه).

\textbf{دستور اجرا:}
\begin{latin}
\begin{lstlisting}
.venv/bin/python main.py --spec examples/sub.json
\end{lstlisting}
\end{latin}

\textbf{خروجی اجرا:}
خروجی دقیقِ اجرا در فایل \lr{\texttt{outputs/run\_results.txt}} ذخیره شده است. خلاصه‌ی نتیجه روی این مثال (در دامنه‌ی محدودِ تعریف‌شده در JSON):
\begin{itemize}
  \item پیش‌شرط ضروری: \lr{\texttt{N >= 0}}
  \item پیش‌شرط‌های زائد: \lr{\texttt{N <= 1000}} ، \lr{\texttt{N >= -100}} ، \lr{\texttt{M >= 0}}
  \item نکته: در بررسی \lr{IC-like}، پیش‌شرط \lr{\texttt{M >= 0}} نتیجه نمی‌شود اما با حذفش همچنان قرارداد برقرار است؛ این دقیقاً نمونه‌ای از تفاوت «استنتاج از پیش‌شرط‌ها» با «لازم بودن برای برنامه» است.
\end{itemize}

\subsection{محدودیت‌ها}
این پیاده‌سازی یک \textbf{prototype آموزشی} است و به‌جای تحلیل کامل C و ابزارهایی مثل \lr{CPAchecker}، از \lr{bounded execution} استفاده می‌کند؛ بنابراین نتیجه‌ها «تضمین کامل برای همه‌ی ورودی‌ها» نیست مگر دامنه ورودی‌ها کامل باشد.

\section{شبیه‌سازی (Benchmark)}
برای مقایسه‌ی ایده‌های مقاله به‌صورت آموزشی، یک شبیه‌سازی کوچک روی مجموعه‌ای از برنامه‌های مصنوعی انجام شد.
در هر برنامه یک پیش‌شرط ضروری و سه پیش‌شرط زائد از سه نوعِ \textbf{Independency}، \textbf{Implication} و \textbf{Range} تزریق شد و سه روش زیر مقایسه شدند:
\begin{itemize}
  \item \lr{IC-like}: بررسی استنتاج منطقی از سایر پیش‌شرط‌ها
  \item \lr{DC-like}: تحلیل وابستگی نحوی از متغیرهای پس‌شرط
  \item \lr{VC}: حذف پیش‌شرط و بررسی مجدد قرارداد (روش معنایی در دامنه محدود)
\end{itemize}

این شبیه‌سازی با دستور زیر اجرا شد و خروجی در \lr{\url{outputs/simulation_summary.txt}} ذخیره گردید:
\begin{latin}
\begin{lstlisting}
.venv/bin/python main.py --simulate --sim_n=39 --sim_seed=1
\end{lstlisting}
\end{latin}

نتیجه‌ی شبیه‌سازی (39 برنامه، مجموع 117 پیش‌شرط زائد):
\begin{table}[tb]
\centering
\begin{tabular}{lrrrr}
\toprule
نوع پیش‌شرط زائد & تعداد واقعی & \lr{IC-like} & \lr{DC-like} & \lr{VC} \\
\midrule
\lr{Independency} & 39 & 0 & 39 & 39 \\
\lr{Implication}  & 39 & 39 & 0 & 39 \\
\lr{Range}        & 39 & 0 & 0 & 39 \\
\midrule
\lr{Total}        & 117 & 39 & 39 & 117 \\
\bottomrule
\end{tabular}
\end{table}

\section{فرآیند اجرای پروژه}
\begin{enumerate}
  \item انتخاب مقاله مرجع و مطالعه (PDF مقاله + اسلاید).
  \item استخراج تعاریف کلیدی (افزونگی تکی/گروهی، ایده‌ی روش‌های IC/DC/PC).
  \item پیاده‌سازی یک prototype کوچک برای بازتولید ایده‌ی «حذف پیش‌شرط و بررسی دوباره» در قالب bounded checking.
  \item اجرای ابزار روی مثال‌ها و ثبت نتایج.
  \item آماده‌سازی گزارش و بسته‌ی نهایی زیپ.
\end{enumerate}

\section{کدهای پروژه / گیت‌هاب}
\begin{itemize}
  \item کد پروژه کوچک است و به‌صورت فایل‌های همین زیپ پیوست می‌شود.
  \item اگر لازم شد روی گیت‌هاب آپلود شود: (لینک اینجا قرار گیرد)
\end{itemize}

\section{پیوست‌ها}
\begin{itemize}
  \item مقاله مرجع (PDF) و اسلایدها در فایل زیپ نهایی قرار داده می‌شوند.
\end{itemize}

\section*{منابع}
\begin{enumerate}
  \item \lr{N. Thoben, H. Wehrheim, ``Detecting Redundant Preconditions,'' FormaliSE 2025, DOI: 10.1109/FORMALISE66629.2025.00015.}
\end{enumerate}

\end{RTL}
\end{document}
